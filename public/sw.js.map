{
  "version": 3,
  "sources": ["../src/service-worker.ts"],
  "sourcesContent": ["/// <reference lib=\"webworker\" />\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nconst CACHE_NAME = 'my-app-cache-v1';\nconst IMAGE_CACHE = 'images-cache-v1';\n\n// Pre-cache these URLs on install\nconst PRECACHE_URLS = ['/'];\n\n// Check if request is same-origin\nfunction isSameOrigin(url: string): boolean {\n  return url.startsWith(self.location.origin);\n}\n\n// Cache-first strategy for same-origin requests\nasync function cacheFirst(request: Request, cacheName: string): Promise<Response> {\n  const cache = await caches.open(cacheName);\n  const cached = await cache.match(request);\n\n  if (cached) {\n    return cached;\n  }\n\n  try {\n    const response = await fetch(request);\n    // Only cache successful same-origin responses or opaque responses\n    if (response.ok || response.type === 'opaque') {\n      cache.put(request, response.clone());\n    }\n    return response;\n  } catch (error) {\n    console.error('[SW] Fetch failed:', error);\n    throw error;\n  }\n}\n\n// Cache-first strategy for cross-origin requests (images, etc.)\nasync function cacheFirstCrossOrigin(request: Request, cacheName: string): Promise<Response> {\n  const cache = await caches.open(cacheName);\n  const cached = await cache.match(request);\n\n  if (cached) {\n    return cached;\n  }\n\n  try {\n    // Use no-cors mode for cross-origin requests\n    const response = await fetch(request.url, {\n      mode: 'no-cors',\n      credentials: 'omit',\n    });\n\n    // Opaque responses (from no-cors) can still be cached\n    if (response.type === 'opaque' || response.ok) {\n      cache.put(request, response.clone());\n    }\n    return response;\n  } catch (error) {\n    console.error('[SW] Cross-origin fetch failed:', error);\n    throw error;\n  }\n}\n\n// Network-first strategy\nasync function networkFirst(request: Request): Promise<Response> {\n  const cache = await caches.open(CACHE_NAME);\n\n  try {\n    const response = await fetch(request);\n    if (response.ok) {\n      cache.put(request, response.clone());\n    }\n    return response;\n  } catch (error) {\n    const cached = await cache.match(request);\n    if (cached) {\n      return cached;\n    }\n    throw error;\n  }\n}\n\nself.addEventListener('install', (event: ExtendableEvent) => {\n  console.log('[SW] Installing...');\n\n  event.waitUntil(\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => cache.addAll(PRECACHE_URLS))\n      .then(() => {\n        console.log('[SW] Installed');\n        return self.skipWaiting();\n      }),\n  );\n});\n\nself.addEventListener('activate', (event: ExtendableEvent) => {\n  console.log('[SW] Activating...');\n\n  // Clean up old caches\n  event.waitUntil(\n    caches\n      .keys()\n      .then((cacheNames) => {\n        return Promise.all(\n          cacheNames\n            .filter((name) => name !== CACHE_NAME && name !== IMAGE_CACHE)\n            .map((name) => caches.delete(name)),\n        );\n      })\n      .then(() => {\n        console.log('[SW] Activated');\n        return self.clients.claim();\n      }),\n  );\n});\n\nself.addEventListener('fetch', (event: FetchEvent) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests\n  if (request.method !== 'GET') {\n    return;\n  }\n\n  // Skip chrome-extension and other non-http requests\n  if (!request.url.startsWith('http')) {\n    return;\n  }\n\n  // Skip WebSocket requests\n  if (url.protocol === 'ws:' || url.protocol === 'wss:') {\n    return;\n  }\n\n  // Handle images (including cross-origin)\n  if (request.destination === 'image') {\n    if (isSameOrigin(request.url)) {\n      event.respondWith(cacheFirst(request, IMAGE_CACHE));\n    } else {\n      // For cross-origin images, let the browser handle it normally\n      // or use no-cors caching strategy\n      event.respondWith(cacheFirstCrossOrigin(request, IMAGE_CACHE));\n    }\n    return;\n  }\n\n  // // Skip cross-origin non-image requests (let browser handle them)\n  // if (!isSameOrigin(request.url)) {\n  //   return;\n  // }\n\n  // // Network-first for API calls\n  // if (url.pathname.startsWith('/api/')) {\n  //   event.respondWith(networkFirst(request));\n  //   return;\n  // }\n\n  // // Cache-first for same-origin static assets\n  // event.respondWith(cacheFirst(request, CACHE_NAME));\n});\n\n// Handle messages from the main thread\nself.addEventListener('message', (event: ExtendableMessageEvent) => {\n  const { type, payload } = event.data || {};\n\n  switch (type) {\n    case 'SKIP_WAITING':\n      console.log('[SW] Skip waiting requested');\n      self.skipWaiting();\n      break;\n\n    case 'GET_VERSION':\n      event.ports[0]?.postMessage({ version: CACHE_NAME });\n      break;\n\n    case 'CLEAR_CACHE':\n      event.waitUntil(\n        (async () => {\n          const cacheName = payload?.cacheName;\n          if (cacheName) {\n            await caches.delete(cacheName);\n            console.log(`[SW] Cache \"${cacheName}\" cleared`);\n          } else {\n            const names = await caches.keys();\n            await Promise.all(names.map((name) => caches.delete(name)));\n            console.log('[SW] All caches cleared');\n          }\n          event.ports[0]?.postMessage({ success: true });\n        })(),\n      );\n      break;\n\n    default:\n      console.log('[SW] Unknown message type:', type);\n  }\n});\n\nexport {};"],
  "mappings": "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",
  "names": []
}
